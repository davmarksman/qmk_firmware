#include "keymap.h"
#include <stdio.h>

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    if (is_keyboard_master()) {
        return OLED_ROTATION_270;
    } else {
        return OLED_ROTATION_270;
    }
}

void render_space(void) {
    oled_write_P(PSTR("     "), false);
}

void render_mod_status_gui_alt(uint8_t modifiers) {
    static const char PROGMEM gui_off_1[] = {0x85, 0x86, 0};
    static const char PROGMEM gui_off_2[] = {0xa5, 0xa6, 0};
    static const char PROGMEM gui_on_1[] = {0x8d, 0x8e, 0};
    static const char PROGMEM gui_on_2[] = {0xad, 0xae, 0};

    static const char PROGMEM alt_off_1[] = {0x87, 0x88, 0};
    static const char PROGMEM alt_off_2[] = {0xa7, 0xa8, 0};
    static const char PROGMEM alt_on_1[] = {0x8f, 0x90, 0};
    static const char PROGMEM alt_on_2[] = {0xaf, 0xb0, 0};

    // fillers between the modifier icons bleed into the icon frames
    static const char PROGMEM off_off_1[] = {0xc5, 0};
    static const char PROGMEM off_off_2[] = {0xc6, 0};
    static const char PROGMEM on_off_1[] = {0xc7, 0};
    static const char PROGMEM on_off_2[] = {0xc8, 0};
    static const char PROGMEM off_on_1[] = {0xc9, 0};
    static const char PROGMEM off_on_2[] = {0xca, 0};
    static const char PROGMEM on_on_1[] = {0xcb, 0};
    static const char PROGMEM on_on_2[] = {0xcc, 0};

    if(modifiers & MOD_MASK_GUI) {
        oled_write_P(gui_on_1, false);
    } else {
        oled_write_P(gui_off_1, false);
    }

    if ((modifiers & MOD_MASK_GUI) && (modifiers & MOD_MASK_ALT)) {
        oled_write_P(on_on_1, false);
    } else if(modifiers & MOD_MASK_GUI) {
        oled_write_P(on_off_1, false);
    } else if(modifiers & MOD_MASK_ALT) {
        oled_write_P(off_on_1, false);
    } else {
        oled_write_P(off_off_1, false);
    }

    if(modifiers & MOD_MASK_ALT) {
        oled_write_P(alt_on_1, false);
    } else {
        oled_write_P(alt_off_1, false);
    }

    if(modifiers & MOD_MASK_GUI) {
        oled_write_P(gui_on_2, false);
    } else {
        oled_write_P(gui_off_2, false);
    }

    if (modifiers & MOD_MASK_GUI & MOD_MASK_ALT) {
        oled_write_P(on_on_2, false);
    } else if(modifiers & MOD_MASK_GUI) {
        oled_write_P(on_off_2, false);
    } else if(modifiers & MOD_MASK_ALT) {
        oled_write_P(off_on_2, false);
    } else {
        oled_write_P(off_off_2, false);
    }

    if(modifiers & MOD_MASK_ALT) {
        oled_write_P(alt_on_2, false);
    } else {
        oled_write_P(alt_off_2, false);
    }
}

void render_mod_status_ctrl_shift(uint8_t modifiers) {
    static const char PROGMEM ctrl_off_1[] = {0x89, 0x8a, 0};
    static const char PROGMEM ctrl_off_2[] = {0xa9, 0xaa, 0};
    static const char PROGMEM ctrl_on_1[] = {0x91, 0x92, 0};
    static const char PROGMEM ctrl_on_2[] = {0xb1, 0xb2, 0};

    static const char PROGMEM shift_off_1[] = {0x8b, 0x8c, 0};
    static const char PROGMEM shift_off_2[] = {0xab, 0xac, 0};
    static const char PROGMEM shift_on_1[] = {0xcd, 0xce, 0};
    static const char PROGMEM shift_on_2[] = {0xcf, 0xd0, 0};

    // fillers between the modifier icons bleed into the icon frames
    static const char PROGMEM off_off_1[] = {0xc5, 0};
    static const char PROGMEM off_off_2[] = {0xc6, 0};
    static const char PROGMEM on_off_1[] = {0xc7, 0};
    static const char PROGMEM on_off_2[] = {0xc8, 0};
    static const char PROGMEM off_on_1[] = {0xc9, 0};
    static const char PROGMEM off_on_2[] = {0xca, 0};
    static const char PROGMEM on_on_1[] = {0xcb, 0};
    static const char PROGMEM on_on_2[] = {0xcc, 0};

    if(modifiers & MOD_MASK_CTRL) {
        oled_write_P(ctrl_on_1, false);
    } else {
        oled_write_P(ctrl_off_1, false);
    }

    if ((modifiers & MOD_MASK_CTRL) && (modifiers & MOD_MASK_SHIFT)) {
        oled_write_P(on_on_1, false);
    } else if(modifiers & MOD_MASK_CTRL) {
        oled_write_P(on_off_1, false);
    } else if(modifiers & MOD_MASK_SHIFT) {
        oled_write_P(off_on_1, false);
    } else {
        oled_write_P(off_off_1, false);
    }

    if(modifiers & MOD_MASK_SHIFT) {
        oled_write_P(shift_on_1, false);
    } else {
        oled_write_P(shift_off_1, false);
    }

    if(modifiers & MOD_MASK_CTRL) {
        oled_write_P(ctrl_on_2, false);
    } else {
        oled_write_P(ctrl_off_2, false);
    }

    if (modifiers & MOD_MASK_CTRL & MOD_MASK_SHIFT) {
        oled_write_P(on_on_2, false);
    } else if(modifiers & MOD_MASK_CTRL) {
        oled_write_P(on_off_2, false);
    } else if(modifiers & MOD_MASK_SHIFT) {
        oled_write_P(off_on_2, false);
    } else {
        oled_write_P(off_off_2, false);
    }

    if(modifiers & MOD_MASK_SHIFT) {
        oled_write_P(shift_on_2, false);
    } else {
        oled_write_P(shift_off_2, false);
    }
}

void render_logo(void) {
    static const char PROGMEM corne_logo[] = {
        0xA0, 0xA1, 0xA2, 0xA3, 0xA4,
        0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0};
    oled_write_P(corne_logo, false);
}

void render_inf(void) {
    static const char PROGMEM inf_logo[] = {
// '4535c364c6507eda6e11498a8cf7736a - Copy', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x0f, 0x37, 0x0b, 0x23, 
0x43, 0x83, 0x63, 0x0b, 0x03, 0x27, 0x0f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xef, 0xef, 0xc3, 0xc7, 0x83, 0x23, 0x17, 0x07, 0x07, 0x03, 0x05, 0x04, 0x00, 0x00, 0x1b, 0x00, 
0x10, 0x10, 0x04, 0x10, 0x80, 0x84, 0x00, 0x00, 0x23, 0x07, 0xe7, 0x1f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfc, 0xfc, 0xe0, 0x00, 0x40, 0x10, 0x02, 
0x40, 0x60, 0x20, 0x81, 0x00, 0x01, 0x00, 0x80, 0xe0, 0xf0, 0xf8, 0xfe, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xf1, 0xf1, 0xf5, 0xe4, 0xe0, 0xe1, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc2, 0xd1, 0xc8, 0xd0, 0xc1, 0xc1, 0xe3, 0xf7, 0xff, 0xff, 0xff, 0xff    
};
    oled_write_raw_P(inf_logo, sizeof(inf_logo));
}

void render_apc(void) {
    static const char PROGMEM apc_logo[] = {
// 'gtk_wolf_1b_he_stinger_by_schwarzweiler-d9nkny2', 32x15px
0xbf, 0x1f, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x07, 0x0f, 0x0f, 0x0f, 0x09, 0x01, 0x01, 0x01, 0x05, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 0xff, 
0x6f, 0x6e, 0x6c, 0x68, 0x68, 0x60, 0x60, 0x60, 0x60, 0x68, 0x68, 0x68, 0x60, 0x60, 0x60, 0x68, 
0x68, 0x68, 0x60, 0x60, 0x60, 0x68, 0x68, 0x68, 0x60, 0x60, 0x60, 0x68, 0x68, 0x6c, 0x6e, 0x6f 
};
    oled_write_raw_P(apc_logo, sizeof(apc_logo));
}


void render_layer_state(void) {
    static const char PROGMEM default_layer[] = {
        0x20, 0x94, 0x95, 0x96, 0x20,
        0x20, 0xb4, 0xb5, 0xb6, 0x20,
        0x20, 0xd4, 0xd5, 0xd6, 0x20, 0};
    static const char PROGMEM sym_layer[] = {
        0x20, 0x97, 0x98, 0x99, 0x20,
        0x20, 0xb7, 0xb8, 0xb9, 0x20,
        0x20, 0xd7, 0xd8, 0xd9, 0x20, 0};
    static const char PROGMEM l1_layer[] = {
        0x20, 0x9a, 0x9b, 0x9c, 0x20,
        0x20, 0xba, 0xbb, 0xbc, 0x20,
        0x20, 0xda, 0xdb, 0xdc, 0x20, 0};
    static const char PROGMEM adjust_layer[] = {
        0x20, 0x9d, 0x9e, 0x9f, 0x20,
        0x20, 0xbd, 0xbe, 0xbf, 0x20,
        0x20, 0xdd, 0xde, 0xdf, 0x20, 0};
    if(layer_state_is(_L1)) {
        oled_write_P(l1_layer, false);
    } else if(layer_state_is(_SYNAV)) {
        oled_write_P(sym_layer, false);
    } else if(layer_state_is(_GAME)) {
        oled_write_P(adjust_layer, false);
    } else {
        oled_write_P(default_layer, false);
    } 
}

static void render_shift(uint8_t modifiers){
    oled_write_P(PSTR("     "), (modifiers & MOD_MASK_SHIFT));
    oled_write_P(PSTR("SHIFT"), (modifiers & MOD_MASK_SHIFT));
    oled_write_P(PSTR("     "), (modifiers & MOD_MASK_SHIFT));
}

static void render_layer_text(void){
    static const char PROGMEM nav_arr[] = {
        0x20, 0x20, 0x18, 0x20, 0x20,
        0x20, 0x1b, 0x19, 0x1a, 0x20,
        0x20, 0x20, 0x20, 0x20, 0x20, 0};

    if(layer_state_is(_L1)) {
        oled_write_P(PSTR("     "), true);
        oled_write_P(PSTR("[{(_*"), true);
        oled_write_P(PSTR("     "), true);
    } else if(layer_state_is(_SYNAV)) {
        oled_write_P(nav_arr, false);
    } else if(layer_state_is(_GAME)) {
        render_apc();
    }  else {
    oled_write_P(PSTR("      "), false);
    oled_write_P(PSTR("      "), false);
    oled_write_P(PSTR("      "), false);
    } 
}


// WPM-responsive animation stuff here
#define IDLE_FRAMES 2
#define IDLE_SPEED 10 // below this wpm value your animation will idle

// #define PREP_FRAMES 1 // uncomment if >1

#define TAP_FRAMES 2
#define TAP_SPEED 30 // above this wpm value typing animation to triggere

#define ANIM_FRAME_DURATION 500 // how long each frame lasts in ms
// #define SLEEP_TIMER 60000 // should sleep after this period of 0 wpm, needs fixing


uint32_t anim_timer = 0;
uint32_t anim_sleep = 0;
uint8_t current_idle_frame = 0;
// uint8_t current_prep_frame = 0; // uncomment if PREP_FRAMES >1
uint8_t current_tap_frame = 0;
uint8_t wpm_val = 0;


static void render_anim(void) {
    static const char PROGMEM idle[IDLE_FRAMES][128] = {
        {
// 'sniper0', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x1f, 0x0f, 0x17, 0x07, 
0x47, 0x07, 0x27, 0x0f, 0x8f, 0x9f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x5f, 0xdf, 0xdf, 0xdf, 0x57, 0x47, 0x0f, 0x57, 0x57, 0x06, 0x0c, 0x19, 0x10, 0x00, 0x12, 0x26, 
0x10, 0x20, 0x0a, 0x00, 0x02, 0x84, 0x00, 0x03, 0x17, 0x17, 0x17, 0x07, 0x0f, 0x0f, 0x1f, 0x3f, 
0xfe, 0xfe, 0xfe, 0xfc, 0xf8, 0xf8, 0xf8, 0xd4, 0xc6, 0xc0, 0xc1, 0xc8, 0x90, 0x80, 0x80, 0x80, 
0x82, 0x84, 0x80, 0x84, 0x81, 0x80, 0x80, 0x80, 0x80, 0x84, 0x80, 0x90, 0x80, 0x80, 0x88, 0x89,      
},
        {
// 'sniper1', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x7f, 0xbf, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x77, 0xe3, 0x4b, 0x00, 
0x00, 0x90, 0x30, 0x82, 0x00, 0x51, 0x00, 0x14, 0x24, 0x01, 0x1f, 0x1f, 0x3f, 0x3f, 0xff, 0xff, 
0xfb, 0xf9, 0xfb, 0xfb, 0xeb, 0xe3, 0xeb, 0xe5, 0xed, 0xed, 0xcd, 0x85, 0x84, 0x80, 0x45, 0x65, 
0x00, 0x00, 0x01, 0x80, 0x01, 0x08, 0x90, 0x08, 0x10, 0x18, 0x00, 0x01, 0x80, 0xc7, 0xf0, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xf3, 0xe1, 0xe1, 0xe5, 0xe0, 
0xe2, 0xe2, 0xe0, 0xe0, 0xe0, 0xe0, 0xc0, 0xc4, 0xc2, 0xc1, 0xca, 0xc0, 0xc0, 0xc3, 0xc7, 0xef, 
        },
    };
    static const char PROGMEM prep[][128] = {
        {
          
// 'marksman', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x7f, 0x3f, 0x5f, 0x1f, 0x1f, 0x1f, 0x9f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xbf, 0x9f, 0xbf, 0xbf, 0xbf, 0x3f, 0xbf, 0x5f, 0xdf, 0xdf, 0xdf, 0x57, 0x47, 0x0b, 0x51, 0x45, 
0x00, 0x00, 0x48, 0x18, 0x41, 0x00, 0x28, 0x00, 0x0a, 0x12, 0x00, 0x0f, 0x8f, 0x1f, 0x9f, 0x7f, 
0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xf8, 0xf8, 0xf8, 0xf4, 0x86, 
0x00, 0x01, 0x40, 0x0b, 0x01, 0x80, 0x80, 0x04, 0x02, 0x06, 0x00, 0x00, 0x80, 0xc0, 0xe3, 0xf8, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xc7, 0xc7, 
0xd4, 0x91, 0x80, 0x84, 0x01, 0x01, 0x00, 0x02, 0x08, 0x44, 0x20, 0x42, 0x07, 0x07, 0x8f, 0xdf
         }
    };
    static const char PROGMEM tap[TAP_FRAMES][128] = {
        {
// 'inf1', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x0f, 0x37, 0x0b, 0x23, 
0x43, 0x83, 0x63, 0x0b, 0x03, 0x27, 0x0f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xef, 0xef, 0xc3, 0xc7, 0x83, 0x23, 0x17, 0x07, 0x07, 0x03, 0x05, 0x04, 0x00, 0x00, 0x1b, 0x00, 
0x10, 0x10, 0x04, 0x10, 0x80, 0x84, 0x00, 0x00, 0x23, 0x07, 0xe7, 0x1f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfc, 0xfc, 0xe0, 0x00, 0x40, 0x10, 0x02, 
0x40, 0x60, 0x20, 0x81, 0x00, 0x01, 0x00, 0x80, 0xe0, 0xf0, 0xf8, 0xfe, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xf1, 0xf1, 0xf5, 0xe4, 0xe0, 0xe1, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc2, 0xd1, 0xc8, 0xd0, 0xc1, 0xc1, 0xe3, 0xf7, 0xff, 0xff, 0xff, 0xff            
},
        {
// 'inf2', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x1f, 0xaf, 0x97, 0x47, 0x87, 0x07, 0xc7, 
0x07, 0x07, 0x4f, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xf0, 0x80, 0x76, 0xc1, 0x22, 0x41, 0x08, 
0x00, 0x00, 0x08, 0x00, 0x00, 0x07, 0x47, 0x0f, 0xcf, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xf7, 0xf7, 0xe0, 0xe3, 0xdb, 0xdb, 0xdb, 0xcb, 0x8b, 0x01, 0x88, 0xc8, 0x00, 0x20, 0x00, 0x00, 
0x10, 0x87, 0x08, 0xc0, 0x20, 0x00, 0x40, 0x20, 0xb1, 0x7c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xc0, 0xc0, 0xc0, 0xc4, 0x8e, 0x80, 
0x80, 0x81, 0x83, 0x82, 0x85, 0x82, 0x82, 0xc0, 0xe2, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
        },
    };

    //assumes 1 frame prep stage
    void animation_phase(void) {
        wpm_val = get_current_wpm() ;
        if(wpm_val<=IDLE_SPEED){

            if(wpm_val <= (rand()% 5 + 3)){
              current_idle_frame  = 0;
            }else{
              current_idle_frame  = 1;
            }

            //current_idle_frame = (current_idle_frame + 1) % IDLE_FRAMES;
            oled_write_raw_P(idle[current_idle_frame], sizeof(idle[current_idle_frame]));
         }
         if(wpm_val >IDLE_SPEED && wpm_val <TAP_SPEED){
             // oled_write_raw_P(prep[abs((PREP_FRAMES-1)-current_prep_frame)], ANIM_SIZE); // uncomment if IDLE_FRAMES >1
             oled_write_raw_P(prep[0], sizeof(prep[0]));  // remove if IDLE_FRAMES >1
         }
         if(wpm_val >=TAP_SPEED){
             current_tap_frame = (current_tap_frame + 1) % TAP_FRAMES;
             oled_write_raw_P(tap[abs((TAP_FRAMES-1)-current_tap_frame)], sizeof(tap[abs((TAP_FRAMES-1)-current_tap_frame)]));
         }
    }
    if(get_current_wpm() != 000) {
        oled_on(); // not essential but turns on animation OLED with any alpha keypress
        if(timer_elapsed32(anim_timer) > ANIM_FRAME_DURATION) {
            anim_timer = timer_read32();
            animation_phase();
        }
        anim_sleep = timer_read32();
    } else {
        if(timer_elapsed32(anim_sleep) > OLED_TIMEOUT) {
            oled_off();
        } else {
            if(timer_elapsed32(anim_timer) > ANIM_FRAME_DURATION) {
                anim_timer = timer_read32();
                animation_phase();
            }
        }
    }
}


void render_status_main(void) {
    render_space();
    render_logo();
    render_space();
    render_layer_state();
    render_space();
    render_mod_status_gui_alt(get_mods()|get_oneshot_mods());
    render_mod_status_ctrl_shift(get_mods()|get_oneshot_mods());
    render_space();
    render_layer_text();
}

void render_status_secondary(void) {
    render_space();
    render_logo();
    render_space();
    render_shift(get_mods()|get_oneshot_mods());
    render_space();
    render_space();
    render_inf();
}



void render_wpm(void) {
    char wpm_counter[6];
    snprintf(wpm_counter, sizeof(wpm_counter), "%3u", get_current_wpm());
    oled_write_P(PSTR("WPM:   "), false);
    oled_write(wpm_counter, false);
}

void oled_task_user(void) {
    if (is_keyboard_master()) {
        // render_space();
        // sprintf(wpm_str, "WPM: %03d", get_current_wpm());
        // oled_write_P(wpm_str, false);
        render_wpm();
        render_space();
        render_anim();

//+ get_current_wpm()
        // oled_write_P(PSTR("WPM:" ), false);
        //render_status_main();
    } else {
        render_status_secondary();
    }
}



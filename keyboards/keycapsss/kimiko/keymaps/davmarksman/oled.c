#include "keymap.h"

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    if (is_keyboard_master()) {
        return OLED_ROTATION_270;
    } else {
        return OLED_ROTATION_270;
    }
}

void render_space(void) {
    oled_write_P(PSTR("     "), false);
}

void render_space_on(void) {
    oled_write_P(PSTR("     "), true);
}
void render_mod_status_gui_alt(uint8_t modifiers) {
    static const char PROGMEM gui_off_1[] = {0x85, 0x86, 0};
    static const char PROGMEM gui_off_2[] = {0xa5, 0xa6, 0};
    static const char PROGMEM gui_on_1[] = {0x8d, 0x8e, 0};
    static const char PROGMEM gui_on_2[] = {0xad, 0xae, 0};

    static const char PROGMEM alt_off_1[] = {0x87, 0x88, 0};
    static const char PROGMEM alt_off_2[] = {0xa7, 0xa8, 0};
    static const char PROGMEM alt_on_1[] = {0x8f, 0x90, 0};
    static const char PROGMEM alt_on_2[] = {0xaf, 0xb0, 0};

    // fillers between the modifier icons bleed into the icon frames
    static const char PROGMEM off_off_1[] = {0xc5, 0};
    static const char PROGMEM off_off_2[] = {0xc6, 0};
    static const char PROGMEM on_off_1[] = {0xc7, 0};
    static const char PROGMEM on_off_2[] = {0xc8, 0};
    static const char PROGMEM off_on_1[] = {0xc9, 0};
    static const char PROGMEM off_on_2[] = {0xca, 0};
    static const char PROGMEM on_on_1[] = {0xcb, 0};
    static const char PROGMEM on_on_2[] = {0xcc, 0};

    if(modifiers & MOD_MASK_GUI) {
        oled_write_P(gui_on_1, false);
    } else {
        oled_write_P(gui_off_1, false);
    }

    if ((modifiers & MOD_MASK_GUI) && (modifiers & MOD_MASK_ALT)) {
        oled_write_P(on_on_1, false);
    } else if(modifiers & MOD_MASK_GUI) {
        oled_write_P(on_off_1, false);
    } else if(modifiers & MOD_MASK_ALT) {
        oled_write_P(off_on_1, false);
    } else {
        oled_write_P(off_off_1, false);
    }

    if(modifiers & MOD_MASK_ALT) {
        oled_write_P(alt_on_1, false);
    } else {
        oled_write_P(alt_off_1, false);
    }

    if(modifiers & MOD_MASK_GUI) {
        oled_write_P(gui_on_2, false);
    } else {
        oled_write_P(gui_off_2, false);
    }

    if (modifiers & MOD_MASK_GUI & MOD_MASK_ALT) {
        oled_write_P(on_on_2, false);
    } else if(modifiers & MOD_MASK_GUI) {
        oled_write_P(on_off_2, false);
    } else if(modifiers & MOD_MASK_ALT) {
        oled_write_P(off_on_2, false);
    } else {
        oled_write_P(off_off_2, false);
    }

    if(modifiers & MOD_MASK_ALT) {
        oled_write_P(alt_on_2, false);
    } else {
        oled_write_P(alt_off_2, false);
    }
}

void render_mod_status_ctrl_shift(uint8_t modifiers) {
    static const char PROGMEM ctrl_off_1[] = {0x89, 0x8a, 0};
    static const char PROGMEM ctrl_off_2[] = {0xa9, 0xaa, 0};
    static const char PROGMEM ctrl_on_1[] = {0x91, 0x92, 0};
    static const char PROGMEM ctrl_on_2[] = {0xb1, 0xb2, 0};

    static const char PROGMEM shift_off_1[] = {0x8b, 0x8c, 0};
    static const char PROGMEM shift_off_2[] = {0xab, 0xac, 0};
    static const char PROGMEM shift_on_1[] = {0xcd, 0xce, 0};
    static const char PROGMEM shift_on_2[] = {0xcf, 0xd0, 0};

    // fillers between the modifier icons bleed into the icon frames
    static const char PROGMEM off_off_1[] = {0xc5, 0};
    static const char PROGMEM off_off_2[] = {0xc6, 0};
    static const char PROGMEM on_off_1[] = {0xc7, 0};
    static const char PROGMEM on_off_2[] = {0xc8, 0};
    static const char PROGMEM off_on_1[] = {0xc9, 0};
    static const char PROGMEM off_on_2[] = {0xca, 0};
    static const char PROGMEM on_on_1[] = {0xcb, 0};
    static const char PROGMEM on_on_2[] = {0xcc, 0};

    if(modifiers & MOD_MASK_CTRL) {
        oled_write_P(ctrl_on_1, false);
    } else {
        oled_write_P(ctrl_off_1, false);
    }

    if ((modifiers & MOD_MASK_CTRL) && (modifiers & MOD_MASK_SHIFT)) {
        oled_write_P(on_on_1, false);
    } else if(modifiers & MOD_MASK_CTRL) {
        oled_write_P(on_off_1, false);
    } else if(modifiers & MOD_MASK_SHIFT) {
        oled_write_P(off_on_1, false);
    } else {
        oled_write_P(off_off_1, false);
    }

    if(modifiers & MOD_MASK_SHIFT) {
        oled_write_P(shift_on_1, false);
    } else {
        oled_write_P(shift_off_1, false);
    }

    if(modifiers & MOD_MASK_CTRL) {
        oled_write_P(ctrl_on_2, false);
    } else {
        oled_write_P(ctrl_off_2, false);
    }

    if (modifiers & MOD_MASK_CTRL & MOD_MASK_SHIFT) {
        oled_write_P(on_on_2, false);
    } else if(modifiers & MOD_MASK_CTRL) {
        oled_write_P(on_off_2, false);
    } else if(modifiers & MOD_MASK_SHIFT) {
        oled_write_P(off_on_2, false);
    } else {
        oled_write_P(off_off_2, false);
    }

    if(modifiers & MOD_MASK_SHIFT) {
        oled_write_P(shift_on_2, false);
    } else {
        oled_write_P(shift_off_2, false);
    }
}

void render_logo(void) {
    static const char PROGMEM corne_logo[] = {
        0xA0, 0xA1, 0xA2, 0xA3, 0xA4,
        0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0};
    oled_write_P(corne_logo, false);
}


void render_apc(void) {
    static const char PROGMEM apc_logo[] = {
// 'gtk_wolf_1b_he_stinger_by_schwarzweiler-d9nkny2', 32x15px
0xbf, 0x1f, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x07, 0x0f, 0x0f, 0x0f, 0x09, 0x01, 0x01, 0x01, 0x05, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 0xff, 
0x6f, 0x6e, 0x6c, 0x68, 0x68, 0x60, 0x60, 0x60, 0x60, 0x68, 0x68, 0x68, 0x60, 0x60, 0x60, 0x68, 
0x68, 0x68, 0x60, 0x60, 0x60, 0x68, 0x68, 0x68, 0x60, 0x60, 0x60, 0x68, 0x68, 0x6c, 0x6e, 0x6f 
};
    oled_write_raw_P(apc_logo, sizeof(apc_logo));
}


void render_layer_state(void) {
    static const char PROGMEM default_layer[] = {
        0x20, 0x94, 0x95, 0x96, 0x20,
        0x20, 0xb4, 0xb5, 0xb6, 0x20,
        0x20, 0xd4, 0xd5, 0xd6, 0x20, 0};
    static const char PROGMEM sym_layer[] = {
        0x20, 0x97, 0x98, 0x99, 0x20,
        0x20, 0xb7, 0xb8, 0xb9, 0x20,
        0x20, 0xd7, 0xd8, 0xd9, 0x20, 0};
    static const char PROGMEM l1_layer[] = {
        0x20, 0x9a, 0x9b, 0x9c, 0x20,
        0x20, 0xba, 0xbb, 0xbc, 0x20,
        0x20, 0xda, 0xdb, 0xdc, 0x20, 0};
    static const char PROGMEM adjust_layer[] = {
        0x20, 0x9d, 0x9e, 0x9f, 0x20,
        0x20, 0xbd, 0xbe, 0xbf, 0x20,
        0x20, 0xdd, 0xde, 0xdf, 0x20, 0};
    if(layer_state_is(_L1)) {
        oled_write_P(l1_layer, false);
    } else if(layer_state_is(_SYNAV)) {
        oled_write_P(sym_layer, false);
    } else if(layer_state_is(_GAME)) {
        oled_write_P(adjust_layer, false);
    } else {
        oled_write_P(default_layer, false);
    } 
}

static void render_shift(uint8_t modifiers){
    oled_write_P(PSTR("     "), (modifiers & MOD_MASK_SHIFT));
    oled_write_P(PSTR("SHIFT"), (modifiers & MOD_MASK_SHIFT));
    oled_write_P(PSTR("     "), (modifiers & MOD_MASK_SHIFT));
}

static void render_layer_text(void){
    static const char PROGMEM nav_arr[] = {
        0x20, 0x20, 0x18, 0x20, 0x20,
        0x20, 0x1b, 0x19, 0x1a, 0x20,
        0x20, 0x20, 0x20, 0x20, 0x20, 0};

    if(layer_state_is(_L1)) {
        render_space_on();
        oled_write_P(PSTR("[{(_*"), true);
        render_space_on();
    } else if(layer_state_is(_SYNAV)) {
        oled_write_P(nav_arr, false);
    } else if(layer_state_is(_GAME)) {
        render_apc();
    }  else {
        render_space();
        render_space();
        render_space();
    } 
}


// WPM-responsive animation stuff here
#define IDLE_SPEED 10 // below this wpm value your animation will idle
#define TAP_FRAMES 5
#define TAP_SPEED 30 // above this wpm value typing animation to triggere
#define ANIM_FRAME_DURATION 400 // how long each frame lasts in ms

uint32_t anim_timer = 0;
uint32_t anim_sleep = 0;
uint8_t current_tap_frame = 0;
uint8_t wpm_val = 0;

static void render_anim(void) {
    static const char PROGMEM idle[128] = {
// 'sniper0', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x1f, 0x0f, 0x17, 0x07, 
0x47, 0x07, 0x27, 0x0f, 0x8f, 0x9f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x5f, 0xdf, 0xdf, 0xdf, 0x57, 0x47, 0x0f, 0x57, 0x57, 0x06, 0x0c, 0x19, 0x10, 0x00, 0x12, 0x26, 
0x10, 0x20, 0x0a, 0x00, 0x02, 0x84, 0x00, 0x03, 0x17, 0x17, 0x17, 0x07, 0x0f, 0x0f, 0x1f, 0x3f, 
0xfe, 0xfe, 0xfe, 0xfc, 0xf8, 0xf8, 0xf8, 0xd4, 0xc6, 0xc0, 0xc1, 0xc8, 0x90, 0x80, 0x80, 0x80, 
0x82, 0x84, 0x80, 0x84, 0x81, 0x80, 0x80, 0x80, 0x80, 0x84, 0x80, 0x90, 0x80, 0x80, 0x88, 0x89,      
    };
    static const char PROGMEM prep[128] = {
// 'sniper1', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x7f, 0xbf, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x77, 0xe3, 0x4b, 0x00, 
0x00, 0x90, 0x30, 0x82, 0x00, 0x51, 0x00, 0x14, 0x24, 0x01, 0x1f, 0x1f, 0x3f, 0x3f, 0xff, 0xff, 
0xfb, 0xf9, 0xfb, 0xfb, 0xeb, 0xe3, 0xeb, 0xe5, 0xed, 0xed, 0xcd, 0x85, 0x84, 0x80, 0x45, 0x65, 
0x00, 0x00, 0x01, 0x80, 0x01, 0x08, 0x90, 0x08, 0x10, 0x18, 0x00, 0x01, 0x80, 0xc7, 0xf0, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xf3, 0xe1, 0xe1, 0xe5, 0xe0, 
0xe2, 0xe2, 0xe0, 0xe0, 0xe0, 0xe0, 0xc0, 0xc4, 0xc2, 0xc1, 0xca, 0xc0, 0xc0, 0xc3, 0xc7, 0xef, 
    };
    static const char PROGMEM tap[TAP_FRAMES][128] = {
        {
// 'infantry0', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x1f, 
0x6f, 0x17, 0x47, 0x87, 0x07, 0xc7, 0x17, 0x07, 0x4f, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xf0, 
0x80, 0x70, 0xc0, 0x20, 0x41, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x47, 0x0f, 0xcf, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf7, 0xf7, 0xf7, 0xf7, 0xe7, 0xe0, 0xc1, 0xc3, 0x83, 0x03, 0x03, 0x01, 
0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xe0, 0xf1, 0xfc, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xe3, 0xe3, 0xe1, 0xe9, 0xc0, 
0xc0, 0xc8, 0xc0, 0x80, 0x80, 0x82, 0x80, 0x80, 0xa4, 0xa1, 0x83, 0x87, 0xc7, 0xef, 0xff, 0xff, 
        },{
// 'infantry1', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x0f, 0x37, 0x0b, 
0x23, 0x43, 0x83, 0x63, 0x0b, 0x03, 0x27, 0x0f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xf8, 0x40, 0x38, 
0x60, 0x10, 0x20, 0x04, 0x00, 0x80, 0x04, 0x00, 0x00, 0x03, 0x23, 0x07, 0xe7, 0x1f, 0xff, 0xff, 
0xff, 0xff, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xf0, 0xf0, 0xe1, 0xe1, 0xe1, 0xc1, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x80, 0x00, 0x08, 0x03, 0x24, 0x80, 0x00, 0x60, 0xe0, 0xf0, 0xf8, 0xfe, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xc6, 
0xc6, 0xc4, 0x80, 0x89, 0x84, 0x81, 0x80, 0x80, 0x86, 0x80, 0x81, 0xc7, 0xef, 0xff, 0xff, 0xff, 
        },{
// 'infantry2', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x1f, 0x6f, 0x17, 0x47, 
0x87, 0x07, 0xc7, 0x17, 0x07, 0x4f, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xf0, 0x80, 0x70, 0xc0, 
0x20, 0x41, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x07, 0x47, 0x0f, 0xcf, 0x3f, 0xff, 0xff, 0xff, 
0xff, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xe0, 0xe1, 0xc3, 0xc3, 0xc3, 0x83, 0x01, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x10, 0x87, 0x08, 0xc0, 0x20, 0x00, 0x40, 0x20, 0xb1, 0x7c, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xc0, 0xc0, 0xc0, 
0xc4, 0x8e, 0x80, 0x80, 0x81, 0x83, 0x82, 0x85, 0x82, 0x82, 0xc0, 0xe2, 0xf8, 0xff, 0xff, 0xff, 
        },{
// 'infantry3', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x1f, 0x6f, 0x17, 
0x47, 0x87, 0x07, 0xc7, 0x17, 0x07, 0x4f, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xf0, 0x80, 0x70, 
0xc0, 0x20, 0x41, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x07, 0x47, 0x0f, 0xcf, 0x3f, 0xff, 0xff, 
0xff, 0xff, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xe0, 0xe1, 0xc3, 0xc3, 0xc3, 0x83, 0x01, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x10, 0x87, 0x48, 0x00, 0x20, 0x40, 0xc0, 0xe0, 0xf1, 0xfc, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xee, 0xc4, 
0x86, 0x84, 0xa0, 0x80, 0x89, 0xb0, 0x80, 0x80, 0x80, 0x81, 0x80, 0xc7, 0xef, 0xff, 0xff, 0xff, 
        },{
// 'infantry4', 32x32px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x1f, 
0x6f, 0x17, 0x47, 0x87, 0x07, 0xc7, 0x17, 0x07, 0x4f, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0x83, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x08, 0x00, 
0x00, 0x10, 0x00, 0x20, 0x21, 0x08, 0x20, 0x00, 0x08, 0x00, 0x00, 0x47, 0x0f, 0xcf, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xfc, 0xf8, 0xf8, 0xc0, 0x00, 
0x80, 0x20, 0x04, 0x80, 0xc0, 0x40, 0x02, 0x01, 0x03, 0x00, 0x00, 0xc0, 0xe0, 0xf1, 0xfc, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xe3, 0xe3, 0xea, 
0xc8, 0xc0, 0xc2, 0x80, 0x80, 0x80, 0x81, 0x84, 0xa2, 0x90, 0xa1, 0x83, 0x83, 0xc7, 0xef, 0xff
        },
    };

    void animation_phase(void) {
        wpm_val = get_current_wpm() ;
        // idle and prep
        if(wpm_val<= TAP_SPEED){
            if(wpm_val <= (rand()% 6) + IDLE_SPEED - 3){
              oled_write_raw_P(idle, sizeof(idle));
            }else{
              oled_write_raw_P(prep, sizeof(prep));
            }
         } else {
             current_tap_frame = (current_tap_frame + 1) % TAP_FRAMES;
             oled_write_raw_P(tap[abs((TAP_FRAMES-1)-current_tap_frame)], sizeof(tap[abs((TAP_FRAMES-1)-current_tap_frame)]));
         }
    }
    if(get_current_wpm() != 000) {
        oled_on(); // not essential but turns on animation OLED with any alpha keypress
        if(timer_elapsed32(anim_timer) > ANIM_FRAME_DURATION) {
            anim_timer = timer_read32();
            animation_phase();
        }
        anim_sleep = timer_read32();
    } else {
        if(timer_elapsed32(anim_sleep) > OLED_TIMEOUT) {
            oled_off();
        } else {
            if(timer_elapsed32(anim_timer) > ANIM_FRAME_DURATION) {
                anim_timer = timer_read32();
                animation_phase();
            }
        }
    }
}

void render_wpm(void) {
    char wpm_counter[5];
    uint8_t n = get_current_wpm();
    wpm_counter[4] = '\0';
    wpm_counter[3] = '0' + n % 10;
    wpm_counter[2] = '0' + (n /= 10) % 10;
    wpm_counter[1] = '0' + n / 10;
    wpm_counter[0] = '>';

    oled_write_P(PSTR(" WPM "), false);
    oled_write_ln(wpm_counter, false);
}
void render_status_main(void) {
    render_space();
    render_logo();
    render_space();
    render_layer_state();
    render_space();
    render_mod_status_gui_alt(get_mods()|get_oneshot_mods());
    render_mod_status_ctrl_shift(get_mods()|get_oneshot_mods());
    render_space();
    render_layer_text();
}

void render_status_secondary(void) {
    render_space();
    render_logo();
    render_space();
    render_shift(get_mods()|get_oneshot_mods());
    render_space();
    render_wpm();
    render_space();
    render_anim();
}

void oled_task_user(void) {
    if (is_keyboard_master()) {
        render_status_main();
    } else {
        render_status_secondary();
    }
}


